from typing import Dict, List, Tuple, Optional, Any, Callable
import collections

State = Tuple[int, Tuple[Tuple[int, int], ...]]
Primitive = Dict[str, Any]
GenSpec = Dict[str, Any]
Gens = List[GenSpec]


def m_at_factory(block_pattern: List[int]) -> Callable[[int], int]:
    """Return m_at(i): modulus at absolute index i determined by repeating block_pattern."""
    if not block_pattern:
        raise ValueError("block_pattern must be non-empty")

    def m_at(i: int) -> int:
        idx = i % len(block_pattern)
        return int(block_pattern[idx])

    return m_at


def normalize_tape(tape: Dict[int, int], m_at: Callable[[int], int]) -> Tuple[Tuple[int, int], ...]:
    """
    Return a sorted tuple of (i,val) with 1 <= val < m(i), dropping zeros.
    """
    out = []
    for i, v in tape.items():
        m = m_at(i)
        if m <= 0:
            raise ValueError(f"Invalid modulus {m} at index {i}")
        vv = int(v) % m
        if vv != 0:
            out.append((int(i), int(vv)))
    out.sort()
    return tuple(out)


def encode_state(p: int, tape: Dict[int, int], m_at: Callable[[int], int]) -> State:
    """Return canonical (p, sorted_tuple) for hashing/equality."""
    return (int(p), normalize_tape(tape, m_at))


def apply_primitive(prim: Primitive, p: int, tape: Dict[int, int], m_at: Callable[[int], int]) -> Tuple[int, Dict[int, int]]:
    """
    Apply one primitive: move(k) or toggle(offset, delta).
    For toggle: index = p + offset; tape[index] = (tape.get(index,0) + delta) mod m(index).
    Drop entry if it becomes 0.
    Returns new (p, tape) where tape is a shallow copy modified.
    """
    if 'move' in prim:
        k = int(prim['move'])
        return p + k, dict(tape)
    if 'toggle' in prim:
        t = prim['toggle']
        offset = int(t.get('offset', 0))
        delta = int(t.get('delta', 1))
        idx = p + offset
        m = m_at(idx)
        newt = dict(tape)
        cur = newt.get(idx, 0)
        nv = (int(cur) + int(delta)) % m
        if nv == 0:
            if idx in newt:
                del newt[idx]
        else:
            newt[idx] = nv
        return p, newt
    raise ValueError(f"Unknown primitive: {prim}")


def apply_word(word: List[Primitive], p: int, tape: Dict[int, int], m_at: Callable[[int], int]) -> Tuple[int, Dict[int, int]]:
    """Fold apply_primitive left-to-right."""
    curp = int(p)
    curtape = dict(tape)
    for prim in word:
        curp, curtape = apply_primitive(prim, curp, curtape, m_at)
    return curp, curtape



def build_ball(
    radius: int,
    gens: Gens,
    block_pattern: List[int] = [2],
) -> Tuple[List[State], List[Tuple[int, int, int]], List[int], List[str]]:
    """
    BFS ball of given radius.
    Each vertex is a unique canonical state (word). Edges are generated by applying
    generators during BFS. For undirected Cayley graphs, pass generators that include
    explicit inverses (e.g., a,t,T).
    Returns V, E, dist, labels
    """
    if radius < 0:
        raise ValueError("radius must be >= 0")

    m_at = m_at_factory(block_pattern)

    # Use provided generators directly (no auto-symmetrize).
    gens_used: List[GenSpec] = list(gens)
    labels: List[str] = [g['name'] for g in gens]

    # root
    root_p = 0
    root_tape: Dict[int, int] = {}
    root_state = encode_state(root_p, root_tape, m_at)

    V: List[State] = []
    E: List[Tuple[int, int, int]] = []
    dist_list: List[int] = []

    visited: Dict[State, int] = {}

    # BFS queue of vids
    from collections import deque

    q = deque()
    vid = 0
    visited[root_state] = vid
    V.append(root_state)
    dist_list.append(0)
    q.append(vid)

    while q:
        u = q.popleft()
        du = dist_list[u]
        if du >= radius:
            continue
        p_u, tape_u = V[u]
        # reconstruct tape dict from canonical tuple
        tape_dict = {i: v for i, v in tape_u}
        for gi, g in enumerate(gens_used):
            newp, newt = apply_word(g['word'], p_u, tape_dict, m_at)
            child_state = encode_state(newp, newt, m_at)
            if child_state not in visited:
                vid_new = len(V)
                visited[child_state] = vid_new
                V.append(child_state)
                dist_list.append(du + 1)
                q.append(vid_new)
            else:
                vid_new = visited[child_state]
            E.append((u, vid_new, gi))

    return V, E, dist_list, labels
