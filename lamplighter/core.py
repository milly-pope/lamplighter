# Type hints removed from function signatures. Original types documented here:
# State: Tuple[int, Tuple[Tuple[int, int], ...]]
# Primitive: Dict[str, Any]
# GenSpec: Dict[str, Any]
# Gens: List[GenSpec]
import collections
from copy import deepcopy


def make_modulus_func(block_pattern):
    """Returns callable function m_at(i): modulus at i.

    Expected: block_pattern: List[int]
    Returns: callable m_at(i) -> int
    """
    if not block_pattern:
        raise ValueError("block_pattern must be non-empty")

    def modulus_at(i: int) -> int:
        idx = i % len(block_pattern) # which block we are in
        return int(block_pattern[idx]) # modulus at that block

    return modulus_at


def encode_state(p, tape, modulus_at):
    """Return normal form (p, sorted_tuple) for hashing/equality.

    Expected: p: int, tape: Dict[int,int], modulus_at: Callable[[int],int]
    Returns: State (normal form for group element equivalence)
    
    Normalize tape: sorted tuple of (i,val) with 1 <= val < m(i), dropping zeros.
    """
    # normalize tape: reduce mod m(i), drop zeros, sort by index
    out = []  # List[Tuple[int,int]]
    for i, v in tape.items():  # tape: Dict[int,int], (index, value) where value is lamp state
        m = modulus_at(i)  # get modulus at index i
        vv = int(v) % m  # reduce value mod m
        if vv != 0:  # if not 0, i.e lamp is on
            out.append((int(i), int(vv)))  # add to output
    out.sort()  # sort by index for normal form
    return p, tuple(out)


def apply_primitive(prim, p, tape, modulus_at):
    """
    Apply one primitive: move(k) or toggle(offset, delta). Where offset is offset for blocks and delta is change in lamp value.
    For toggle: index = p + offset; tape[index] = (tape.get(index,0) + delta) mod m(index).
    Drop entry if it becomes 0.
    Returns new (p, tape) where tape is a shallow copy modified.
    """
    if 'move' in prim:
        k = int(prim['move'])
        return p + k, tape
    if 'toggle' in prim:
        t = prim['toggle']
        offset = int(t['offset'])
        delta = int(t['delta'])
        idx = p + offset # index to toggle
        m = modulus_at(idx)
        newt = deepcopy(tape) # deep copy for safety
        cur = newt.get(idx, 0) # get current value at index, 0 if not present
        nv = (int(cur) + int(delta)) % m
        if nv == 0:
            if idx in newt:
                del newt[idx]
        else:
            newt[idx] = nv
        return p, newt
    


def apply_word(word, p, tape, modulus_at):
    """Call apply_primitive for each primitive generator in generators that are words.

    Expected: word: List[Primitive], p: int, tape: Dict[int,int]
    """
    curp = p
    curtape = tape
    for prim in word:
        curp, curtape = apply_primitive(prim, curp, curtape, modulus_at)
    return curp, curtape



def build_ball(radius, gens, block_pattern=[2]):
    """
    BFS ball of given radius.
    Each vertex is a unique canonical state (word). Edges are generated by applying
    generators during BFS. For undirected Cayley graphs, pass generators that include
    explicit inverses (e.g., a,t,T).
    Returns V, E, dist, labels
    """
    if radius < 0:
        raise ValueError("radius must be >= 0")

    modulus_at = make_modulus_func(block_pattern)

    # Use provided generators directly (no auto-symmetrize).
    gens_used = list(gens)  # List[GenSpec]
    labels = [g['name'] for g in gens]  # List[str]

    # root
    root_p = 0
    root_tape = {}  # Dict[int,int]
    root_state = encode_state(root_p, root_tape, modulus_at)

    V = []  # List[State]  # state of form (p, tape) where tape is sorted tuple
    E = []  # List[Tuple[int,int,int]]  # edges of form (u,v,gi)
    dist_list = []  # List[int]  # distance from root for each vertex where index is vid

    visited = {}  # Dict[State,int]

    # BFS queue of vids
    from collections import deque

    q = deque()
    vid = 0
    visited[root_state] = vid
    V.append(root_state)
    dist_list.append(0) 
    q.append(vid)

    while q:
        u = q.popleft()
        du = dist_list[u] # distance of u
        if du >= radius:
            continue
        p_u, tape_u = V[u] # (position, tape) of u
        # reconstruct tape dict from canonical tuple
        tape_dict = {i: v for i, v in tape_u} # dict form
        # apply each generator
        for gi, g in enumerate(gens_used): # generator index and spec, we use indicied to label edges instead of generators themselves
            newp, newt = apply_word(g['word'], p_u, tape_dict, modulus_at) #g['word'] used as we only need what the generatord does passed into aapply_word
            child_state = encode_state(newp, newt, modulus_at) # normal form of next tape and position state
            if child_state not in visited:
                vid_new = len(V)
                visited[child_state] = vid_new
                V.append(child_state)
                dist_list.append(du + 1)
                q.append(vid_new)
            else:
                vid_new = visited[child_state] #we have seen it to get the vid of already seen and set it to this so the vertext which we ALWAYS append gets sent to already seen state
            E.append((u, vid_new, gi))

    return V, E, dist_list, labels
